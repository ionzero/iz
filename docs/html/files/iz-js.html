<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>iz.js</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script><script language=JavaScript src="../javascript/prettify.js"></script><script language=JavaScript src="../javascript/searchdata.js"></script></head><body class="ContentPage" onLoad="NDOnLoad();prettyPrint();"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.52 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="iz.js"></a>iz.js</h1><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#iz.js" >iz.js</a></td><td class=SDescription></td></tr><tr class="SClass"><td class=SEntry><a href="#IZ_Object_System" >IZ Object System</a></td><td class=SDescription>The IZ Object System, or <b>iz</b>, provides a mechanism for the creation of robust javascript objects. </td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#IZ_Object_System.Class_definition_methods" >Class definition methods</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.iz.Package(classname,inheritance,class_function)" id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">iz.<wbr>Package(classname, inheritance, class_function)</a></td><td class=SDescription>Creates a new package prototype and registers it&rsquo;s namespace.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.Class.has(attributename,definition)" >Class.<wbr>has(attributename, definition)</a></td><td class=SDescription>Defines a new object attribute.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.Class.mixin(class_or_object,overlay_attributes)" >Class.<wbr>mixin(class_or_object, overlay_attributes)</a></td><td class=SDescription>Adds the functionality of the given class or object to Class by copying all the methods and attributes of the provided class onto the current object. </td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.SUPER(obj,methodname)" >SUPER(obj, methodname)</a></td><td class=SDescription>SUPER is a special function used to retrieve a superclass&rsquo; version of a given method bound to the provided object. </td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#IZ_Object_System.IZ_utility_routines" >IZ utility routines</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.iz.Use(classname,callback)" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">iz.<wbr>Use(classname, callback)</a></td><td class=SDescription>Ensures that classname is loaded and available to be used.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.iz.Tetchy(true_or_false)" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">iz.<wbr>Tetchy(true_or_false)</a></td><td class=SDescription>Tells IZ whether it should be particularly tetchy about common misuses / coding mistakes. </td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.iz.Module(classname)" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">iz.<wbr>Module(classname)</a></td><td class=SDescription>Returns the class with the name provided.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.iz.add_search_path(path)" >iz.<wbr>add_search_path(path)</a></td><td class=SDescription>On server-side environments such as node, adds a path to be searched when loading IZ based modules using iz.Use(). </td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.proto.new_object(args)" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">proto.<wbr>new_object(args)</a></td><td class=SDescription>Creates a new instance of the package class.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.iz.get_metadata(obj)" id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">iz.<wbr>get_metadata(obj)</a></td><td class=SDescription>Inspects an object and returns information about it. </td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.Class.CONSTRUCT(args,[object_to_localize])" >Class.<wbr>CONSTRUCT(args, [object_to_localize])</a></td><td class=SDescription>CONSTRUCT is called immediately after a new object is created. </td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.Class._on_object_create" >Class.<wbr>_on_object_create</a></td><td class=SDescription>The _on_object_create method is used to run any object level initialization required immediately upon creation of a new object. </td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#IZ_Object_System.Object_instance_methods" >Object instance methods</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.obj.does(classname)" >obj.<wbr>does(classname)</a></td><td class=SDescription>Introspection routine, returns true if obj can do what classname does. </td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.obj.isa(classname)" >obj.<wbr>isa(classname)</a></td><td class=SDescription>Introspection routine, returns true if obj is a member or subclass of the class provided, false otherwise. </td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.obj.can(methodname)" >obj.<wbr>can(methodname)</a></td><td class=SDescription>Introspection routine, returns true if obj has a method called &lsquo;methodname&rsquo;</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.obj.get_default(attributename)" >obj.<wbr>get_default(attributename)</a></td><td class=SDescription>Returns the default value for a given attribute. </td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#IZ_Object_System.obj.get_current_state" >obj.<wbr>get_current_state()</a></td><td class=SDescription>The get_current_state method returns a flat &lsquo;generic&rsquo; javascript object representing the state of the object. </td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#IZ_Object_System.obj.localize" >obj.<wbr>localize()</a></td><td class=SDescription>localize returns an object to use in place of the original. </td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="IZ_Object_System"></a>IZ Object System</h2><div class=CBody><p>The IZ Object System, or <b>iz</b>, provides a mechanism for the creation of robust javascript objects.&nbsp;  Some features are:</p><ul><li>Multi-level class-like inheritance</li><li>Mixins</li><li>object intro-spection</li><li>simple attribute creation</li><li>protected attributes that may only be get and set via method calls</li><li>attribute type checking (including user-defined checking)</li><li>deep object localization.</li></ul><p>IZ is designed to make working with Objects in Javascript exceedingly easy.&nbsp;  It provides a clean way to create objects and object hierarchies in Javascript.&nbsp; IZ does this in a way that will be familiar to most developers who have worked with object oriented concepts in other languages.&nbsp; Behind the scenes, the IZ object system does this in a very Javascript native way and in the most efficient way possible, using prototypical inheritence and other Javascript native mechanisms.</p><p>The end result is a very usable and approachable way of writing and using objects in javascript, with complete support for features and abilities that, while possible, are complex to implement in standard javascript.</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">var Parrot = iz.Use('Animal.Bird.Parrot');
var myparrot = new Parrot({ mimic : 'duck' });
myparrot.makesound(); // quack!
myparrot.mimic('cow');
myparrot.makesound(); // moo!</pre></blockquote><p>Note that while we use the term &lsquo;Class&rsquo; frequently in this documentation, it is important to know that Javascript has no notion of a Class or Class namespace.&nbsp; IZ borrows the term and nomenclature for familiarity and ease of understanding only.&nbsp; IZ uses prototypical inheritance and uses &lsquo;Class names&rsquo; only as a mechanism for naming and retrieving prototypes.</p><p>For more information on Javascript&rsquo;s prototypical inheritance (and many other goodies), please refer to Douglas Crockford&rsquo;s excellent book, &lsquo;Javascript: The Good Parts.&rsquo;</p><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGroup"><td class=SEntry><a href="#IZ_Object_System.Class_definition_methods" >Class definition methods</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.iz.Package(classname,inheritance,class_function)" id=link7 onMouseOver="ShowTip(event, 'tt1', 'link7')" onMouseOut="HideTip('tt1')">iz.<wbr>Package(classname, inheritance, class_function)</a></td><td class=SDescription>Creates a new package prototype and registers it&rsquo;s namespace.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.Class.has(attributename,definition)" >Class.<wbr>has(attributename, definition)</a></td><td class=SDescription>Defines a new object attribute.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.Class.mixin(class_or_object,overlay_attributes)" >Class.<wbr>mixin(class_or_object, overlay_attributes)</a></td><td class=SDescription>Adds the functionality of the given class or object to Class by copying all the methods and attributes of the provided class onto the current object. </td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.SUPER(obj,methodname)" >SUPER(obj, methodname)</a></td><td class=SDescription>SUPER is a special function used to retrieve a superclass&rsquo; version of a given method bound to the provided object. </td></tr><tr class="SGroup"><td class=SEntry><a href="#IZ_Object_System.IZ_utility_routines" >IZ utility routines</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.iz.Use(classname,callback)" id=link8 onMouseOver="ShowTip(event, 'tt2', 'link8')" onMouseOut="HideTip('tt2')">iz.<wbr>Use(classname, callback)</a></td><td class=SDescription>Ensures that classname is loaded and available to be used.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.iz.Tetchy(true_or_false)" id=link9 onMouseOver="ShowTip(event, 'tt3', 'link9')" onMouseOut="HideTip('tt3')">iz.<wbr>Tetchy(true_or_false)</a></td><td class=SDescription>Tells IZ whether it should be particularly tetchy about common misuses / coding mistakes. </td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.iz.Module(classname)" id=link10 onMouseOver="ShowTip(event, 'tt4', 'link10')" onMouseOut="HideTip('tt4')">iz.<wbr>Module(classname)</a></td><td class=SDescription>Returns the class with the name provided.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.iz.add_search_path(path)" >iz.<wbr>add_search_path(path)</a></td><td class=SDescription>On server-side environments such as node, adds a path to be searched when loading IZ based modules using iz.Use(). </td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.proto.new_object(args)" id=link11 onMouseOver="ShowTip(event, 'tt5', 'link11')" onMouseOut="HideTip('tt5')">proto.<wbr>new_object(args)</a></td><td class=SDescription>Creates a new instance of the package class.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.iz.get_metadata(obj)" id=link12 onMouseOver="ShowTip(event, 'tt6', 'link12')" onMouseOut="HideTip('tt6')">iz.<wbr>get_metadata(obj)</a></td><td class=SDescription>Inspects an object and returns information about it. </td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.Class.CONSTRUCT(args,[object_to_localize])" >Class.<wbr>CONSTRUCT(args, [object_to_localize])</a></td><td class=SDescription>CONSTRUCT is called immediately after a new object is created. </td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.Class._on_object_create" >Class.<wbr>_on_object_create</a></td><td class=SDescription>The _on_object_create method is used to run any object level initialization required immediately upon creation of a new object. </td></tr><tr class="SGroup"><td class=SEntry><a href="#IZ_Object_System.Object_instance_methods" >Object instance methods</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.obj.does(classname)" >obj.<wbr>does(classname)</a></td><td class=SDescription>Introspection routine, returns true if obj can do what classname does. </td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.obj.isa(classname)" >obj.<wbr>isa(classname)</a></td><td class=SDescription>Introspection routine, returns true if obj is a member or subclass of the class provided, false otherwise. </td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.obj.can(methodname)" >obj.<wbr>can(methodname)</a></td><td class=SDescription>Introspection routine, returns true if obj has a method called &lsquo;methodname&rsquo;</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.obj.get_default(attributename)" >obj.<wbr>get_default(attributename)</a></td><td class=SDescription>Returns the default value for a given attribute. </td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#IZ_Object_System.obj.get_current_state" >obj.<wbr>get_current_state()</a></td><td class=SDescription>The get_current_state method returns a flat &lsquo;generic&rsquo; javascript object representing the state of the object. </td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#IZ_Object_System.obj.localize" >obj.<wbr>localize()</a></td><td class=SDescription>localize returns an object to use in place of the original. </td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.Class_definition_methods"></a>Class definition methods</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.iz.Package(classname,inheritance,class_function)"></a>iz.<wbr>Package(classname, inheritance, class_function)</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Package = function (</td><td class="PParameter  prettyprint " nowrap>packagename,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>inheritance,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>closure</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Creates a new package prototype and registers it&rsquo;s namespace.</p><p>Inheritance can be defined using two mechanisms.&nbsp;  First, &lsquo;extends&rsquo;, provides a base class for the class to be created.&nbsp;  This can be an IZ classname, a function or another object.&nbsp;  This will be used as the prototype for  objects of this class.&nbsp;  Note that when providing a function to extends, node&rsquo;s util.inherits() is used to accomplish the inheritance.&nbsp;  The second mechanism for inheritance is the mixin.&nbsp;  While only a single item may be specified for &lsquo;extends&rsquo;, multiple mixins may be specified using an array.&nbsp;  You can provide an IZ class name or an object as a mixin.&nbsp;  Note that you may use &lsquo;extends&rsquo; and &lsquo;mixin&rsquo; on the same class in the same iz.Package definition.</p><p>The function in the iz.Package() call is used to create a <u>prototype</u> object for the given class.&nbsp; The <b>Class</b> object passed to the function will have all the inheritance and mixin behavior specified in the inheritance argument already added and will be ready for your own definitions.&nbsp; This allows you to override any inherited behavior within your class definition.&nbsp;  It is vital that you remember to return the Class at the end of the function.&nbsp;  This is used as the prototype for all objects created using this class.&nbsp;   As such, any state created within the class_function would be shared  by ALL objects created using this class.</p><p>The second argument to the class_function is &lsquo;SUPER&rsquo; which is a method used to access the superclass&rsquo; methods for this class.&nbsp;  Additional information about SUPER is available later in this documentation.</p><p>Note also that in the case where you are not inheriting anything, you can omit the inheritance argument altogether.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>classname</td><td class=CDLDescription>Namespace of class to be created</td></tr><tr><td class=CDLEntry>inheritance</td><td class=CDLDescription>Object containing inheritance details</td></tr><tr><td class=CDLEntry>class_function</td><td class=CDLDescription>Function reference containing the body of the class to be created.</td></tr></table><h4 class=CHeading>Returns</h4><p>Class creation function</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">iz.Package( 'MyAwesomeClass',
              {
                   extends: 'MyOtherClass',
                   mixin: [ 'Classname', my_useful_object ]
              },

              // Class is passed in and Class must be returned.
              function (Class, SUPER) {
                    // add things to Class

                    // it's very important to return Class;
                    return Class;
              });</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.Class.has(attributename,definition)"></a>Class.<wbr>has(attributename, definition)</h3><div class=CBody><p>Defines a new object attribute.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>attributename</td><td class=CDLDescription>Attribute name to add</td></tr><tr><td class=CDLEntry>definition</td><td class=CDLDescription>Attribute definition object literal</td></tr></table><p>When you define an attribute, an accessor method is created for that attribute.&nbsp; This accessor is created using the attributename provided.&nbsp;  To obtain the value of the attribute, simply call the accessor.&nbsp;  To set the value, call the accessor with the new value as the only argument.&nbsp;  For example, to set and read an attribute called &lsquo;age&rsquo;:</p><blockquote><pre class="prettyprint">// sets age to 27
this.age(27);

// returns 27.
this.age();</pre></blockquote><h4 class=CHeading>Attribute Definition</h4><p>The definition provides information about the attribute.&nbsp;  The available options are:</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>isa</td><td class=CDLDescription>defines a type requirement for this element.&nbsp;   valid options are: boolean, number, string, function, array, object and classname (iz class name)</td></tr><tr><td class=CDLEntry>readonly</td><td class=CDLDescription>Sets attribute to be read-only (true/false) Read only values can only be set in the new() call.&nbsp;  All other     attempts to set a value will fail.</td></tr><tr><td class=CDLEntry>default</td><td class=CDLDescription>provides a default value for the field if none is provided during the new() call.&nbsp; Note that the default will    be shared by all instances of the class, and thus only simple types should use default.&nbsp;  To set defaults on    complex attributes (objects, arrays, etc.) should use a builder.</td></tr><tr><td class=CDLEntry>builder</td><td class=CDLDescription>function to be used to get a default value.&nbsp;  &lsquo;<b>this</b>&rsquo; will be the object the builder is being called on, and   the first argument will be the field name the builder is being called on.&nbsp;  called as: this.builder(fieldname)   Should return the value to be used as the default.&nbsp; This is usually preferable to default on attributes of complex types such as objects and arrays.</td></tr><tr><td class=CDLEntry>check_value</td><td class=CDLDescription>function that is used to override the type checking with custom behavior.&nbsp;  Called with attribute details as first argument, attribute name as second and value as the third.&nbsp;  Note that setting this overrides IZ&rsquo;s internal type checking.&nbsp; Called as: this.check_value(attribute_details, fieldname, value)</td></tr><tr><td class=CDLEntry>private</td><td class=CDLDescription>boolean indicating that this attribute is private. accessors for private attributes are not added to the final object.&nbsp;  See the example below for how to use private attributes.</td></tr></table><p><b>Note</b> that the builder / default values are not set until the value is requested, not at object creation.&nbsp;  This can have  unexpected results if your builder routine is time-sensitive (and might be a good reason to create an init- type method instead).</p><h4 class=CHeading>Returns</h4><p>accessor function for this attribute (not bound to this) Unless you are dealing with private attributes, it is safe to ignore the return value of has();</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">// within Package definition
Class.has('friends', {
                       isa: 'array',
                       builder: function (name) {
                                                   // create an array if we didn't get one.
                                                   return new Array();
                                                }

                   })</pre></blockquote><p>It is possible to create multiple attributes with a single &lsquo;has&rsquo; call by passing an object with attribute name / definition pairs.&nbsp;  This is best understood using an example:</p><blockquote><pre class="prettyprint">Class.has({
    server: { isa: 'object' },
    port: { isa: 'number', default: 80 },
    max_size: { isa: 'number', default: 1000000 },
});</pre></blockquote><p>As mentioned above, it is possible to create private attributes that are only accessible by class methods.&nbsp; The mechanism for doing this is straightforward, if somewhat non-intuitive.&nbsp; The <b>has</b> operator returns the accessor function for the given attribute.&nbsp;  Using this along with javascript&rsquo;s bind() routine allows you to tie the method to the given instance.&nbsp;  A code example will make this clearer:</p><blockquote><pre class="prettyprint">// within the Package definition

// this creates an age attribute, but you can not call object.age() as the accessor is never added.
var age_prv = Class.has('age', { isa: 'number', private: true });

Class.do_something_with_age = function(new_age) {

    // this gets us an accessor for age that we can work with.
    // note that this must be done in each method that needs access to age, as it must be bound to this
    var age = age_prv.bind(this);

    // this sets age.
    age(new_age);
}</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.Class.mixin(class_or_object,overlay_attributes)"></a>Class.<wbr>mixin(class_or_object, overlay_attributes)</h3><div class=CBody><p>Adds the functionality of the given class or object to Class by copying all the methods and attributes of the provided class onto the current object.&nbsp;  Mixins allow you to merge multiple objects or clases together.</p><p>This can be especially useful when you want to create functionality that would apply to many different types or classes of object.&nbsp; Creating a class intended to be mixed in will allow you to add that functionality to any object regardless of it&rsquo;s inheritance structure.&nbsp; In IZ mixins can be applied at the class level or at the instance level, allowing run-time addition of defined functionality.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>class_or_object</td><td class=CDLDescription>Class or Object to mix in</td></tr><tr><td class=CDLEntry>oberlay_attributes</td><td class=CDLDescription>optional array of attributes to mix in.</td></tr></table><h4 class=CHeading>Returns</h4><p>The original object.</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">// do.stuff is a subclass of thingdoer
iz.Package('do.stuff', { extends: 'thingdoer' }, function (Class, SUPER) {

       // Also, a duck.
       Class.mixin('Duck');

       Class.do_things = function () {
           console.log('doing things!  also: ' + Class.quack() );
       };
       return Class;
   });</pre></blockquote><ul><li>OR -</li></ul><blockquote><pre class="prettyprint">var stuffdoer = new iz.Module('do.stuff')();
// mix in OtherThings into this instance only
stuffdoer.mixin('OtherThings');</pre></blockquote><p>Note that an optional overlay_attributes parameter can be added to specify the specific attributes to copy.&nbsp;  This parameter is an array of attributes to be copied from the source object.&nbsp; Great care should be taken if you provide overlay_attributes as many methods have expectations about what is available on the object they are attached to.&nbsp; Therefore this second parameter should only be used when you are intimately familiar with the package in question.</p><p>If you are creating classes to be included via the <b>mixin</b> mechanism, you can control what attributes are mixed in from your class.&nbsp; You do this by adding an attribute called &lsquo;overlay_attributes&rsquo; to your object or class.&nbsp;  Within this attribute, place an array containing the list of attribute names you want to have mixed-in to the recipient class or object.&nbsp;  Only those attributes specified will be mixed-in.&nbsp; (Note that if overlay_attributes is provided to the mixin call, it will override your object&rsquo;s overlay_attributes attribute)</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.SUPER(obj,methodname)"></a>SUPER(obj, methodname)</h3><div class=CBody><p>SUPER is a special function used to retrieve a superclass&rsquo; version of a given method bound to the provided object.&nbsp; SUPER is provided as the second argument to the iz.Package&rsquo;s class creation function, as such it can be used within any method created within the class.&nbsp;  It is usually called as follows:</p><blockquote><pre class="prettyprint">iz.Package('Bird.Duck', { extends: 'Bird'}, function(Class, SUPER) {

    Class.take_off = function() {
        SUPER(this, 'take_off')();
        // do other Duck related take-off things
    };
});</pre></blockquote><p>A note about SUPER: Access to an object&rsquo;s superclass methods can be difficult to accomplish reliably in javascript.&nbsp;  IZ&rsquo;s SUPER sidesteps these issues and creates a reliable mechanism for accessing the methods an object inherits, provided it is called as a function as described above.&nbsp; SUPER can, in fact, be called as a method, obj.SUPER(methodname), however doing this within a method will behave unreliably.&nbsp; It is provided only for the rare situation where you need to access the superclass from outside a named method or in a situation where the method is created after object creation.&nbsp;  It is recommended that you avoid the obj.SUPER() calling semantics unless you know exactly what you are doing.</p></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.IZ_utility_routines"></a>IZ utility routines</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.iz.Use(classname,callback)"></a>iz.<wbr>Use(classname, callback)</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Use = function (</td><td class="PParameter  prettyprint " nowrap>packagename,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>callback</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Ensures that classname is loaded and available to be used.</p><p>Use will load the class if it has not been loaded before, otherwise it uses the class that has already been loaded.&nbsp; After loading, you can instantiate:</p><blockquote><pre class="prettyprint">iz.Use('My.Module');
var mymodule = new iz.Module('My.Module');</pre></blockquote><p>Under node.js, this will load the class using require().&nbsp;  Note that when the module has already been loaded, it will not be reloaded and iz.Use() will instead behave like iz.Module() in these cases.&nbsp;  Note also that while iz.Use() does not currently load files in the browser environment, you may use IZ in the browser if you preload your dependencies.&nbsp; (we are open to ideas to reliably accomplish in-browser loading)</p><h4 class=CHeading>Class naming and filenames</h4><p>Class names are separated by periods &lsquo;.&rsquo; representing containing namespace.&nbsp;  When the object is being loaded with &lsquo;Use&rsquo; this namespace is translated to a path.&nbsp;  Each class component preceeding a . is treated as a directory.&nbsp;  For example, to load &lsquo;MyApp.Animals.MegaDuck&rsquo;, IZ would treat the file to be loaded as &lsquo;MyApp/Animals/MegaDuck.js&rsquo;</p><p><b>Path concerns:</b> Under node, IZ uses standard node module loading behavior, meaning that your modules need to be in a directory that node&rsquo;s require can find.&nbsp;  This means that your modules need to be rooted in a node_modules directory somewhere or in your NODE_PATH.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>classname</td><td class=CDLDescription>Class to be loaded</td></tr><tr><td class=CDLEntry>callback</td><td class=CDLDescription>optional callback to call upon module load.</td></tr></table><p>Returns nothing</p><blockquote><pre class="prettyprint">var MegaDuckClass = iz.Use('My.Animals.MegaDuck');</pre></blockquote><p>Note that when running under node.js, class loading is synchronous so the callback mechanism is unneccessary.&nbsp;  In systems that do not support synchronous require, the callback may be used to ensure code that depends on the module is not run until it is available.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.iz.Tetchy(true_or_false)"></a>iz.<wbr>Tetchy(true_or_false)</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Tetchy = function (</td><td class="PParameter  prettyprint " nowrap>tetchy</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Tells IZ whether it should be particularly tetchy about common misuses / coding mistakes.&nbsp; IZ will generally try to &lsquo;do the right thing&rsquo; when in ambiguous or confusing situations.</p><p>If iz.Tetchy() is set to true, IZ will be very picky about how you write your code and will throw exceptions when it encounters things it considers likely to be an error.</p><p>For example, If you pass misnamed or unknown attributes to an object constructor, with iz.Tetchy() set to false, IZ will simply ignore these extra fields.&nbsp; With iz.Tetchy() set to true, it will throw an exception if it encounters a key it doesn&rsquo;t recognize.&nbsp; Another example is that IZ will throw an exception if you attempt to inherit from a class that has not been loaded.</p><p>Generally speaking, Tetchy will enforce some rules that might be helpful during development / debugging.&nbsp; Tetchy does add a very small amount of overhead in various situations.&nbsp; This overhead is minimal and will not have much, if any, effect on a normal application.&nbsp; Likewise if you wrote your code well, it is not necessary, so it is by default set to false.</p><p>Note also that Tetchy is set globally for all IZ derived objects so turning it on in an application that uses modules you did not write can be problematic.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.iz.Module(classname)"></a>iz.<wbr>Module(classname)</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Module = function (</td><td class="PParameter  prettyprint " nowrap>packagename</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Returns the class with the name provided.</p><p>Almost always used with a preceeding &lsquo;new&rsquo;.&nbsp; (See Example)</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>classname</td><td class=CDLDescription>Name of the class to obtain.&nbsp; NEW: classname should be sent through .Use function first either directly or indirectly through other means (iz.Package, etc)</td></tr></table><h4 class=CHeading>Returns</h4><p>Prototype Function for the class provided.</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">var bad_duck = new iz.Module('Somewhere.Animals.SuperDuck')({ &quot;disposition&quot;: &quot;evil&quot; });</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.iz.add_search_path(path)"></a>iz.<wbr>add_search_path(path)</h3><div class=CBody><p>On server-side environments such as node, adds a path to be searched when loading IZ based modules using iz.Use().&nbsp; In most cases, the normal path resolution provided by node is adequate.&nbsp; In many cases, setting NODE_PATH appropriately is preferable.&nbsp;  If neither is adequate, adding a search path may be your only alternative.&nbsp;  Note that this adds overhead to every iz.Use() call so it&rsquo;s recommended not to use this unless you know what you are doing.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.proto.new_object(args)"></a>proto.<wbr>new_object(args)</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>proto.new_object = function (</td><td class="PParameter  prettyprint " nowrap>args,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>object_to_localize</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Creates a new instance of the package class.</p><p>Note: This method should not be called directly, instead use the new operator.&nbsp; Refer to the example for proper way to create an instance of a class.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>args</td><td class=CDLDescription>Object literal containing attributes to be set upon object creation.</td></tr></table><h4 class=CHeading>Returns</h4><p>Instance of the prototype class.</p><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">var good_duck = new iz.Module('Somewhere.Animals.SuperDuck')({ &quot;disposition&quot;: &quot;good&quot; });</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.iz.get_metadata(obj)"></a>iz.<wbr>get_metadata(obj)</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.get_metadata = function(</td><td class="PParameter  prettyprint " nowrap>obj</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Inspects an object and returns information about it.&nbsp; Things that should not be modified directly are localized.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>obj</td><td class=CDLDescription>an IZ class.</td></tr></table><h4 class=CHeading>Returns</h4><p>A javascript object containing attributes for &lsquo;classname&rsquo;, &lsquo;does&rsquo; and &lsquo;attributes&rsquo; which describe the class&rsquo;s structure.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.Class.CONSTRUCT(args,[object_to_localize])"></a>Class.<wbr>CONSTRUCT(args, [object_to_localize])</h3><div class=CBody><p>CONSTRUCT is called immediately after a new object is created.&nbsp; The arguments passed in the &lsquo;new&rsquo; call are passed in to the CONSTRUCT method.&nbsp; The default CONSTRUCT is sufficient in most cases and is what is responsible for setting initial attribute values and for calling superclass constructors.&nbsp; Note that classes used as mixins do not have their CONSTRUCT method called.</p><p><b>NOTE:</b> Overriding CONSTRUCT can cause unusual behavior, it is best to leave CONSTRUCT alone unless you need special class-level initialization during the new call.&nbsp; This is NOT the way to create a factory, or to do other random class hijinks.&nbsp; In other words, if you are thinking about overriding CONSTRUCT, think hard.&nbsp;  Then think again.&nbsp;  Then write an init() method instead.&nbsp;  If you can&rsquo;t make that work, write a passing test for your module then add CONSTRUCT... and remember to call the superclass&rsquo; CONSTRUCT, and return &lsquo;this&rsquo;.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>args</td><td class=CDLDescription>Object literal containing attributes to be set upon object creation.</td></tr></table><h4 class=CHeading>Returns</h4><p>Instance of the object class to be returned to the caller.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.Class._on_object_create"></a>Class.<wbr>_on_object_create</h3><div class=CBody><p>The _on_object_create method is used to run any object level initialization required immediately upon creation of a new object.&nbsp;  This is not intended to be a general purpose initialization routine, but instead a mechanism to do any initialization that may be necessary for inherited classes, etc.&nbsp;  For example, when inheriting from stream.Readable, you must call the stream.Readable construct mechanism so that it can initialize it&rsquo;s own state, the _on_object_craete method is the place to do that.</p><blockquote><pre class="prettyprint">module.exports = iz.Package('MyInputStream', { extends: stream.Readable }, function(Class, SUPER) {

    Class._on_object_create = function(args) {
        // initialize ourselves using the stream.Readable
        stream.Readable.apply(this, args.readable_options);
    };

    return Class;
});</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.Object_instance_methods"></a>Object instance methods</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.obj.does(classname)"></a>obj.<wbr>does(classname)</h3><div class=CBody><p>Introspection routine, returns true if obj can do what classname does.&nbsp;  This checks both for subclassing as well as mixins.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>classname</td><td class=CDLDescription>Class to inquire about</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>bool</td><td class=CDLDescription>True / False</td></tr></table><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">if (obj.does('Duck')) {
   // Here we only care if you can act like a duck
   obj.quack();
}</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.obj.isa(classname)"></a>obj.<wbr>isa(classname)</h3><div class=CBody><p>Introspection routine, returns true if obj is a member or subclass of the class provided, false otherwise.&nbsp; Useful for checking actual class membership.&nbsp; <b>NOTE</b> in most cases you probably want to use &lt;obj.does()&gt; instead.&nbsp; Note - Calling without an argument will return the object&rsquo;s class name.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>classname</td><td class=CDLDescription>Class to inquire about</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>bool</td><td class=CDLDescription>True / False</td></tr></table><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">if (!obj.isa('Duck')) {
      // here you MUST be a duck or a duck subclass.
      throw new Error(&quot;HEY! Only REAL ducks are allowed here!&quot;);
}</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.obj.can(methodname)"></a>obj.<wbr>can(methodname)</h3><div class=CBody><p>Introspection routine, returns true if obj has a method called &lsquo;methodname&rsquo;</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>methodname</td><td class=CDLDescription>method to inquire about</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>bool</td><td class=CDLDescription>True / False</td></tr></table><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">if (obj.can('quack')) {
    // Here we only care if you can quack
    obj.quack();
}</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.obj.get_default(attributename)"></a>obj.<wbr>get_default(attributename)</h3><div class=CBody><p>Returns the default value for a given attribute.&nbsp;  Uses the &lsquo;default&rsquo; value or the &lsquo;builder&rsquo; function as set in the attribute definition.&nbsp;  Note that this returns the default, it does not set the field to that default.&nbsp;  If you want to do that, you will need to set the value to the result of this call.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>attributename</td><td class=CDLDescription>attribute to inquire about</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>value</td><td class=CDLDescription>default value the field would have.</td></tr></table><h4 class=CHeading>Example</h4><blockquote><pre class="prettyprint">var friend_default = obj.get_default('friend');</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.obj.get_current_state"></a>obj.<wbr>get_current_state()</h3><div class=CBody><p>The get_current_state method returns a flat &lsquo;generic&rsquo; javascript object representing the state of the object.&nbsp; This object only contains the attributes and their values as key-value pairs.&nbsp; Keep in mind that the returned object has no connection to the original whatsoever.&nbsp;  As such, modifying its values will have no effect on the original object, nor will it&rsquo;s values keep in sync with the original.&nbsp;  This is, in short, primarily useful for inspection, as IZ object attributes are private and will not be visible via things like node&rsquo;s util.inspect() routine.</p><p>The get_current_state method also provides a simple way to clone an object, as you can call get_current_state and pass the resulting object to the class&rsquo; constructor.</p><p>Note that get_current_state by default only loads attributes created with has(), if you have other private data or state it is recommended that you override this method in your class;</p><blockquote><pre class="prettyprint">// clone my_message_object
var cloned_msg_obj = new Message( my_message_object.get_current_state() );

// cloned_msg_obj and my_message_object now have the same state.
// We can use node's util.inspect to verify this
console.log(&quot;my_message_object: &quot;  + util.inspect(my_message_object.get_current_state()));
console.log(&quot;cloned_msg_obj: &quot;  + util.inspect(cloned_msg_obj.get_current_state()));</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="IZ_Object_System.obj.localize"></a>obj.<wbr>localize()</h3><div class=CBody><p>localize returns an object to use in place of the original.&nbsp;  It should have the state of the original, but any writes should affect only the new object.&nbsp;  Ideally a localized object should see changes made to the original if they have not been overridden in the localized object.&nbsp; That is to say, a localized object should be &lsquo;copy on write&rsquo; wherever possible.&nbsp;  This method implements a generic localization routine for IZ objects, you may override this method if you need special handling.</p><blockquote><pre class="prettyprint">var original = {};
original.name = 'foo';
original.age = 18;

// localize my object
var localized_obj = iz.localize(original);

// outputs localized_obj.name = foo
console.log(&quot;localized_obj.name = &quot; + localized_obj.name);

// setting name only affects name, the original age sticks around.
localized_obj.name = 'bar';

// outputs original.name = foo
console.log(&quot;original.name = &quot; + original.name);

// outputs localized_obj.name = bar
console.log(&quot;localized_obj.name = &quot; + localized_obj.name);

// outputs localized_obj.age = 18
console.log(&quot;localized_obj.age = &quot; + localized_obj.age);

// setting the original in the parent is reflected in the localized copy, so long
// as the localized copy has not yet been overridden. (happy birthday!)
original.age = 19;

// outputs localized_obj.age = 19
console.log(&quot;localized_obj.age = &quot; + localized_obj.age);</pre></blockquote></div></div></div>

</div><!--Content-->


<div id=Footer><a href="http://www.naturaldocs.org">Generated by Natural Docs</a></div><!--Footer-->


<div id=Menu><div class=MEntry><div class=MFile id=MSelected>iz.js</div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Index</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MIndex><a href="../index/General.html">Everything</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Files.html">Files</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div></div></div></div><script type="text/javascript"><!--
var searchPanel = new SearchPanel("searchPanel", "HTML", "../search");
--></script><div id=MSearchPanel class=MSearchPanelInactive><input type=text id=MSearchField value=Search onFocus="searchPanel.OnSearchFieldFocus(true)" onBlur="searchPanel.OnSearchFieldFocus(false)" onKeyUp="searchPanel.OnSearchFieldChange()"><select id=MSearchType onFocus="searchPanel.OnSearchTypeFocus(true)" onBlur="searchPanel.OnSearchTypeFocus(false)" onChange="searchPanel.OnSearchTypeChange()"><option  id=MSearchEverything selected value="General">Everything</option><option value="Classes">Classes</option><option value="Files">Files</option><option value="Functions">Functions</option></select></div></div><!--Menu-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Package = function (</td><td class="PParameter  prettyprint " nowrap>packagename,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>inheritance,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>closure</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Creates a new package prototype and registers it&rsquo;s namespace.</div></div><div class=CToolTip id="tt2"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Use = function (</td><td class="PParameter  prettyprint " nowrap>packagename,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>callback</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Ensures that classname is loaded and available to be used.</div></div><div class=CToolTip id="tt3"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Tetchy = function (</td><td class="PParameter  prettyprint " nowrap>tetchy</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Tells IZ whether it should be particularly tetchy about common misuses / coding mistakes. </div></div><div class=CToolTip id="tt4"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.Module = function (</td><td class="PParameter  prettyprint " nowrap>packagename</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Returns the class with the name provided.</div></div><div class=CToolTip id="tt5"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>proto.new_object = function (</td><td class="PParameter  prettyprint " nowrap>args,</td></tr><tr><td></td><td class="PParameter  prettyprint " nowrap>object_to_localize</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Creates a new instance of the package class.</div></div><div class=CToolTip id="tt6"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>iz.get_metadata = function(</td><td class="PParameter  prettyprint " nowrap>obj</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Inspects an object and returns information about it. </div></div><!--END_ND_TOOLTIPS-->




<div id=MSearchResultsWindow><iframe src="" frameborder=0 name=MSearchResults id=MSearchResults></iframe><a href="javascript:searchPanel.CloseResultsWindow()" id=MSearchResultsWindowClose>Close</a></div>


<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>